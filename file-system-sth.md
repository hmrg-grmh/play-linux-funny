## FS

文件系统。文件的系统。管理文件的存储、访问。对外提供形式统一的接口。

*这个文档的内容仅代表作者的主观认识，不确保完全合乎客观事实。阅读内容时请批判对待，兼听则明。作者本身也会不断修改它。*

### File

文件(文件名): 形式统一的，用于完成数据访问(增删改查)功能的，由文件系统提供的**接口**。

一个文件一般有一下部分：

- 文件数据: 记录了文件的内容。
- 文件元数据: 记录了文件的元信息以及与数据内容位置的关联。**并不记录于文件数据中**。
  其中有:
  
  - inode 号: 一个 inode 号与一个文件是一一对应的。**一个文件不一定只有一个全文件名**，比如所有的*目录文件*都是至少有两个全路径名的。
  - 文件类型 - 具体有以下:
  
    - 普通文件： 标记符为 `-` (normal)
    - 目录文件： 标记符为 `d` (directory)
    - 字符设备文件： 标记符为 `c` (character)
    - 块设备文件： 标记符为 `b` (block)
    - 套接字文件： 标记符为 `s` (socket)
    - 管道文件： 标记符为 `p` (pipe)
    - 链接文件： 标记符为 `l` (link)
    
  - 日期信息: 创建/修改日期等等 ...
  - 还有其它很多信息 ...
  
- 文件名: 一个文件的对外暴露接口(路径+文件名/全文件名)。
  在非对象存储的传统的文件系统中，它通过*目录树*形成与记录: 即通过一系列的*目录文件*的内容来存储，相当于是**存在了别的文件(类型是*目录*)的*文件数据*里**了。

### Inode

*一个文件(数据)有一个唯一的 inode 对应，一个 inode 也只会对应一个文件(数据)。*

根据文件名可以得到 inode : `stat <filename>` 。
或者用于批量查看**非目录文件**的 inode : `ls -i <dir/xx*>` 。

对文件进行:

- 限同一个文件系统(即同一个磁盘分区/卷)内的移动
- 或重命名

的操作，并不会改变文件的 inode 。

inode 的容量也是有个数限制的。见下文。

### Volume

容量。

查看:

- 查看每个卷的文件内数据容量使用情况: `df -h`
- 查看每个卷的文件 Inode 容量使用情况: `df -i`
  指定卷查看也可以这样: `dumpe2fs -h /dev/sda1 | grep 'Inode size'`
  根据占用比例排序: `df -i|awk '{print$5,$1,$6}' OFS='\t'|sort`

更改:

- Inode 容量只能在创建文件系统时指定: `mkfs -t <filesys,eg:ext4> -I <inodesize,eg:16777216> /dev/sda1`
  就是说：这样会丢掉 `/dev/sda1` 内本来的数据。

### Visit

访问(增删改查)。

逻辑步骤:

1. 通过文件名确定 Inode
2. 通过 Inode 确定文件从而确定文件内容
3. 根据*文件类型*的不同，会有**不同的*后续步骤***。

另外，新建目录或文件，或者新建一个软链接，总之，**新增了一个访问接口**，本质上只是，在一个*目录类型文件*里，新增了一行字符串的内容(会有与特定 Inode 的对应)。

### Link

硬链接/软链接:

- *链接类型文件*指的就是*软链接*。
- *硬链接*其实就是**一个 Inode 与之对应的文件名(全路径名)** 。在这里，每个文件名(全路径名)就是一个硬链接。
  通过 `stat <filename>` 查到的信息中，显示的硬链接个数，其实就是指这个文件的文件名(全路径名)个数。

文件访问步骤:

- 硬链接: 访问任何一个硬链接的系统逻辑是没有区别的，都是通过文件名拿到 Inode 然后得到文件内容，然后根据**文件类型不同**会有不同的***后续步骤***。
- 软链接: 即访问一个*链接类型文件*，在*得到文件内容*之后，**所有的*链接类型文件*都会有这样的后续步骤**: 把文件内容视为本次访问的真正目的地，然后**重新经过_访问步骤(就是上面那个逻辑步骤)_** 

软链接与硬链接的不同就在于:

- 软链接，它是另一个文件，有着另一个 Inode 号。一个软连接文件也可以像别的文件那样有多个文件名，也就是有多个硬链接。访问任何一个名字(名字其实就是接口)就是访问这同一个文件，而软连接文件的不同于别的文件的地方就是，它的存储内容一般会是另一个合法的路径(不合法的话系统会以某种途径警告你)，而访问软链接，会经过与别的文件相同的步骤，直到**拿到这段内容**，然后由于其文件元数据中已经明确它是链接类型文件，因此处理的后续就是把这个内容当作真正要访问的路径去访问，**无所谓这个路径所指的文件又是什么类型**：如果又是软链接，那就继续按照软链接的访问步骤办事。这使得软链接可以形成链式的访问跳转。当然，这个后续自动步骤只是**一般而言**，在程序特殊指定了后续步骤的时候，就会有完全不同的后续步骤，比如只是存储这个内容(例子: `tar` 命令打包)。
- 硬链接，它只是**文件系统的特性**，只是**同一个文件(无所谓什么类型)的另一个名字**，或者干脆可以就叫**同一块数据有不止一个访问接口**。**因此硬链接不能(像软链接那样)跨文件系统**。**删除一个 Inode 的所有对应的文件名即会导致该文件被视为删除**。

特别的:

- 目录被**禁止**由用户创建或删除硬链接。而在创建新的目录文件时，系统会自动增加其本身一个硬链接与其外层目录的一个硬链接。
- 根目录 `/` 是特殊的目录文件。它的自身目录硬链接 `.` 和外层目录硬链接 `..` 是相同的 Inode 。
  就是说，根目录文件至少有三个硬链接，其余普通目录至少有两个硬链接。目录内增加一个目录，该目录(即被增加目录的外层目录)会因此增加一个硬链接。

### Mount

(not-ready)...

### Envs

(not-ready)...

### Statement

本文中认为，*命令*可以有多条带结尾符的*语句*组成。

[*命令*]和[*语句*]都由命令本身的名称和结尾符号共同标志，有些情况下，有的结尾符号可以省略。

在这里的定义中，*命令*和*语句*的区别只在于: **在终端写完*结尾符*后回车能否触发命令的执行**。
*语句结尾符*后回车，**不会触发任何执行**，命令结尾符则**一定会**。

执行*成功*还是*失败*的定义:

- *成功*: 返回码是 256 的整数倍。如 0, 256, 512 等。
- *失败*: 返回码是非上述的别的数字。

返回码的定义可以通过 `return <codenum>` 或 `exit <codenum>` 来定义 (后者会导致*其所在进程*退出前者不会但会终端函数 (`function`) ) 。

命令执行**完**后，会在**同一个进程环境**的上下文中的 `$?` 变量中写入**最近一次命令执行完成后返回的**返回码。

其实，**返回码**是一定会小于 256 的。手动返回的返回码，会被模以 `%` 256 后，才是真正的*返回码*，也就是执行 `echo $?` 时会看到的那个。

*结尾符*有以下:

- `;`: 表示 本条执行完后执行下一条。*命令*的结尾符。
- `&`: 表示 本条*后台*执行**并立即开始**执行下一条。*命令*的结尾符。
- `&&`: 表示 本条执行完后**如果*成功*则**执行下一条。*语句*的结尾符。
- `||`: 表示 本条执行完后**如果*失败*则**执行下一条。*语句*的结尾符。
- `|`: 表示 本条的所有*标准输出* (`/dev/stdout`) ，会成为后面一条的*标准错误* (`/dev/stdin`) 。它会导致的行为跟上面四个都不太一样，比如它会特殊地构建一个*进程树*来把一条管道的每部分作为一个进程管理。详细见[Pipe]章节 (或者自行搜索我先咕咕咕) 。

大括号可以**把多条*命令*变为一个整体**，成为**一条命令**。

大括号注意它的前后必须要有空白符，否则会造成**其它的语义**，这是SHell的特性。如果只写一行，那么大括号中每条命令的结尾符 (`;`,`&`) 务必要显式地写上。

### Functions

***函数本质上就是被变为一个整体的多条命令***。 (总之并不是函数式里的那个函数的含义，虽然有些相像的地方。)

函数并不会在 `$PATH` 中的目录中产生文件，它同那些环境变量是一样的:

- 在文件的内容部分中定义 (不一定是硬盘有可能是控制台终端输入(/dev/stdin))
- 定义命令被执行并**不会生成新的文件**而只是让一些信息**在一个比较长的周期内一直存在于内存之中**。

函数相关命令:

- `declare -f`: 查看所有已经定义，即当前生效可用的函数。后面可跟多个函数名从而只列出这些函数的定义。把 `-f` 换为 `-F` 可以只是查看函数名。
- `typeset -f`: 查看所有已经定义，即当前生效可用的函数。后面可跟多个函数名从而只列出这些函数的定义。把 `-f` 换为 `-F` 可以只是查看函数名。(**同上**)
- `unset -f <funcname>`: 指定函数名使其定义无效化，也就是从当前内存上下文(环境)中删了这个函数。
- `type <funcname>`: 检查指定字符串是不是一个函数的名字，会按照**生效的优先顺序**显示这个字符串的生效的身份。比如，如果**同时**是*别名* (`alias`) 则会被算作别名，该命令也会说这个字串是一个别名的名字，而不会说它是函数的名字了。
- `<funcname> ...`: 函数执行的命令形式，和脚本其实是一样的。**函数执行的本质是，定义的函数体在当前环境下被依照定义执行**。**实际上，被大括号包围的代码块本身就是一个*匿名函数* (即定义后立即在定义处调用、被调用次数一定等于被定义次数) ，就是说：函数本质上就是被变为一个整体的多条命令**。
- `function <funcname> () { xxx ; xxx ; }`: 完整的函数定义形式是这么写。关于定义:
  
  - 实际上 `function` 和 `()` 可以选择**其中一个**省略掉。
  - 定义函数只是把函数体定义写入内存，**并不会执行它们**。在这个写入内存的过程中，**所有的别名都会先被转换为其原来代表的内容**。所以，如果函数体里有的语句是**使用别名定义**的，请**先确保*定义别名的 `alias` 命令*完成执行、使得别名在当前上下文(内存)生效**，然后再执行**这个函数**的**定义**。
  - 函数支持递归定义，即*在自身的定义中调用自身*，**但并没有尾递归优化**。而且，当函数名和 `$PATH` 路径们下的文件名重复时，**以这个名称执行的命令，会优先调用函数而非某个可执行文件**。这就导致了这种情况: **像 `function ls () { ls -l ; }` 这样的定义，只会造成，执行 `ls ...` 命令的时候，造成*无限递归*，从而卡死，最终被系统提示 `段错误 (core dumped)` 并退出，类似于在没有尾递归优化的语言中，使用*无限尾递归*的时候那样**。

其实有一个挺可惜的地方就是：如果能在显示函数定义的时候，也能显示我只传一部分参数，它定义应该相当于什么样的话，SHell上就可以玩儿类似*偏函数*的东西了。 :(


### Pipe

(not ready ...)

## 简单总结

- 文件名是文件系统暴露出来的数据*访问*接口。
- 文件有不同类型。对于*链接类型文件*，其内容代表了本次访问会被重定向的路径。
- 新增一个*访问接口*，本质上即是在某个目录文件里新增了一行字符串。改变也是同理，改变字串内容，或者把某个 Inode 绑定给另一个新的目录里的新的字串。
- ...



